/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
/// <reference types="node" resolution-mode="require"/>
import type { Buffer } from 'node:buffer';
import { URL, URLSearchParams } from 'node:url';
import { checkServerIdentity } from 'node:tls';
import http from 'node:http';
import https from 'node:https';
import type { Readable } from 'node:stream';
import type { Socket } from 'node:net';
import type { SecureContextOptions, DetailedPeerCertificate } from 'node:tls';
import type { Agent as HttpAgent, ClientRequest } from 'node:http';
import type { RequestOptions as HttpsRequestOptions, Agent as HttpsAgent } from 'node:https';
import CacheableLookup from 'cacheable-lookup';
import http2wrapper, { type ClientHttp2Session } from 'http2-wrapper';
import type { FormDataLike } from 'form-data-encoder';
import type { StorageAdapter } from 'cacheable-request';
import type ResponseLike from 'responselike';
import type { IncomingMessageWithTimings } from '@szmarczak/http-timer';
import type { CancelableRequest } from '../as-promise/types.js';
import type { PlainResponse, Response } from './response.js';
import type { RequestError } from './errors.js';
import type { Delays } from './timed-out.js';
type Promisable<T> = T | Promise<T>;
export type DnsLookupIpVersion = undefined | 4 | 6;
type Except<ObjectType, KeysType extends keyof ObjectType> = Pick<ObjectType, Exclude<keyof ObjectType, KeysType>>;
export type NativeRequestOptions = HttpsRequestOptions & CacheOptions & {
    checkServerIdentity?: CheckServerIdentityFunction;
};
type AcceptableResponse = IncomingMessageWithTimings | ResponseLike;
type AcceptableRequestResult = Promisable<AcceptableResponse | ClientRequest> | undefined;
export type RequestFunction = (url: URL, options: NativeRequestOptions, callback?: (response: AcceptableResponse) => void) => AcceptableRequestResult;
export type Agents = {
    http?: HttpAgent | false;
    https?: HttpsAgent | false;
    http2?: unknown | false;
};
export type Headers = Record<string, string | string[] | undefined>;
export type ToughCookieJar = {
    getCookieString: ((currentUrl: string, options: Record<string, unknown>, cb: (error: Error | null, cookies: string) => void) => void) & ((url: string, callback: (error: Error | null, cookieHeader: string) => void) => void);
    setCookie: ((cookieOrString: unknown, currentUrl: string, options: Record<string, unknown>, cb: (error: Error | null, cookie: unknown) => void) => void) & ((rawCookie: string, url: string, callback: (error: Error | null, result: unknown) => void) => void);
};
export type PromiseCookieJar = {
    getCookieString: (url: string) => Promise<string>;
    setCookie: (rawCookie: string, url: string) => Promise<unknown>;
};
export type InitHook = (init: OptionsInit, self: Options) => void;
export type BeforeRequestHook = (options: Options) => Promisable<void | Response | ResponseLike>;
export type BeforeRedirectHook = (updatedOptions: Options, plainResponse: PlainResponse) => Promisable<void>;
export type BeforeErrorHook = (error: RequestError) => Promisable<RequestError>;
export type BeforeRetryHook = (error: RequestError, retryCount: number) => Promisable<void>;
export type AfterResponseHook<ResponseType = unknown> = (response: Response<ResponseType>, retryWithMergedOptions: (options: OptionsInit) => never) => Promisable<Response | CancelableRequest<Response>>;
/**
All available hooks of Got.
*/
export type Hooks = {
    /**
    Called with the plain request options, right before their normalization.

    The second argument represents the current `Options` instance.

    @default []

    **Note:**
    > - This hook must be synchronous.

    **Note:**
    > - This is called every time options are merged.

    **Note:**
    > - The `options` object may not have the `url` property. To modify it, use a `beforeRequest` hook instead.

    **Note:**
    > - This hook is called when a new instance of `Options` is created.
    > - Do not confuse this with the creation of `Request` or `got(â€¦)`.

    **Note:**
    > - When using `got(url)` or `got(url, undefined, defaults)` this hook will **not** be called.

    This is especially useful in conjunction with `got.extend()` when the input needs custom handling.

    For example, this can be used to fix typos to migrate from older versions faster.

    @example
    ```
    import got from 'got';

    const instance = got.extend({
        hooks: {
            init: [
                plain => {
                    if ('followRedirects' in plain) {
                        plain.followRedirect = plain.followRedirects;
                        delete plain.followRedirects;
                    }
                }
            ]
        }
    });

    // Normally, the following would throw:
    const response = await instance(
        'https://example.com',
        {
            followRedirects: true
        }
    );

    // There is no option named `followRedirects`, but we correct it in an `init` hook.
    ```

    Or you can create your own option and store it in a context:

    ```
    import got from 'got';

    const instance = got.extend({
        hooks: {
            init: [
                (plain, options) => {
                    if ('secret' in plain) {
                        options.context.secret = plain.secret;
                        delete plain.secret;
                    }
                }
            ],
            beforeRequest: [
                options => {
                    options.headers.secret = options.context.secret;
                }
            ]
        }
    });

    const {headers} = await instance(
        'https://httpbin.org/anything',
        {
            secret: 'passphrase'
        }
    ).json();

    console.log(headers.Secret);
    //=> 'passphrase'
    ```
    */
    init: InitHook[];
    /**
    Called right before making the request with `options.createNativeRequestOptions()`.

    This hook is especially useful in conjunction with `got.extend()` when you want to sign your request.

    @default []

    **Note:**
    > - Got will make no further changes to the request before it is sent.

    **Note:**
    > - Changing `options.json` or `options.form` has no effect on the request. You should change `options.body` instead. If needed, update the `options.headers` accordingly.

    @example
    ```
    import got from 'got';

    const response = await got.post(
        'https://httpbin.org/anything',
        {
            json: {payload: 'old'},
            hooks: {
                beforeRequest: [
                    options => {
                        options.body = JSON.stringify({payload: 'new'});
                        options.headers['content-length'] = options.body.length.toString();
                    }
                ]
            }
        }
    );
    ```

    **Tip:**
    > - You can indirectly override the `request` function by early returning a [`ClientRequest`-like](https://nodejs.org/api/http.html#http_class_http_clientrequest) instance or a [`IncomingMessage`-like](https://nodejs.org/api/http.html#http_class_http_incomingmessage) instance. This is very useful when creating a custom cache mechanism.
    > - [Read more about this tip](https://github.com/sindresorhus/got/blob/main/documentation/cache.md#advanced-caching-mechanisms).
    */
    beforeRequest: BeforeRequestHook[];
    /**
    The equivalent of `beforeRequest` but when redirecting.

    @default []

    **Tip:**
    > - This is especially useful when you want to avoid dead sites.

    @example
    ```
    import got from 'got';

    const response = await got('https://example.com', {
        hooks: {
            beforeRedirect: [
                (options, response) => {
                    if (options.hostname === 'deadSite') {
                        options.hostname = 'fallbackSite';
                    }
                }
            ]
        }
    });
    ```
    */
    beforeRedirect: BeforeRedirectHook[];
    /**
    Called with a `RequestError` instance. The error is passed to the hook right before it's thrown.

    This is especially useful when you want to have more detailed errors.

    @default []

    ```
    import got from 'got';

    await got('https://api.github.com/repos/sindresorhus/got/commits', {
        responseType: 'json',
        hooks: {
            beforeError: [
                error => {
                    const {response} = error;
                    if (response && response.body) {
                        error.name = 'GitHubError';
                        error.message = `${response.body.message} (${response.statusCode})`;
                    }

                    return error;
                }
            ]
        }
    });
    ```
    */
    beforeError: BeforeErrorHook[];
    /**
    The equivalent of `beforeError` but when retrying. Additionally, there is a second argument `retryCount`, the current retry number.

    @default []

    **Note:**
    > - When using the Stream API, this hook is ignored.

    **Note:**
    > - When retrying, the `beforeRequest` hook is called afterwards.

    **Note:**
    > - If no retry occurs, the `beforeError` hook is called instead.

    This hook is especially useful when you want to retrieve the cause of a retry.

    @example
    ```
    import got from 'got';

    await got('https://httpbin.org/status/500', {
        hooks: {
            beforeRetry: [
                (error, retryCount) => {
                    console.log(`Retrying [${retryCount}]: ${error.code}`);
                    // Retrying [1]: ERR_NON_2XX_3XX_RESPONSE
                }
            ]
        }
    });
    ```
    */
    beforeRetry: BeforeRetryHook[];
    /**
    Each function should return the response. This is especially useful when you want to refresh an access token.

    @default []

    **Note:**
    > - When using the Stream API, this hook is ignored.

    **Note:**
    > - Calling the `retryWithMergedOptions` function will trigger `beforeRetry` hooks. If the retry is successful, all remaining `afterResponse` hooks will be called. In case of an error, `beforeRetry` hooks will be called instead.
    Meanwhile the `init`, `beforeRequest` , `beforeRedirect` as well as already executed `afterResponse` hooks will be skipped.

    @example
    ```
    import got from 'got';

    const instance = got.extend({
        hooks: {
            afterResponse: [
                (response, retryWithMergedOptions) => {
                    // Unauthorized
                    if (response.statusCode === 401) {
                        // Refresh the access token
                        const updatedOptions = {
                            headers: {
                                token: getNewToken()
                            }
                        };

                        // Update the defaults
                        instance.defaults.options.merge(updatedOptions);

                        // Make a new retry
                        return retryWithMergedOptions(updatedOptions);
                    }

                    // No changes otherwise
                    return response;
                }
            ],
            beforeRetry: [
                error => {
                    // This will be called on `retryWithMergedOptions(...)`
                }
            ]
        },
        mutableDefaults: true
    });
    ```
    */
    afterResponse: AfterResponseHook[];
};
export type ParseJsonFunction = (text: string) => unknown;
export type StringifyJsonFunction = (object: unknown) => string;
/**
All available HTTP request methods provided by Got.
*/
export type Method = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'HEAD' | 'DELETE' | 'OPTIONS' | 'TRACE' | 'get' | 'post' | 'put' | 'patch' | 'head' | 'delete' | 'options' | 'trace';
export type RetryObject = {
    attemptCount: number;
    retryOptions: RetryOptions;
    error: RequestError;
    computedValue: number;
    retryAfter?: number;
};
export type RetryFunction = (retryObject: RetryObject) => Promisable<number>;
/**
An object representing `limit`, `calculateDelay`, `methods`, `statusCodes`, `maxRetryAfter` and `errorCodes` fields for maximum retry count, retry handler, allowed methods, allowed status codes, maximum [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) time and allowed error codes.

Delays between retries counts with function `1000 * Math.pow(2, retry) + Math.random() * 100`, where `retry` is attempt number (starts from 1).

The `calculateDelay` property is a `function` that receives an object with `attemptCount`, `retryOptions`, `error` and `computedValue` properties for current retry count, the retry options, error and default computed value.
The function must return a delay in milliseconds (or a Promise resolving with it) (`0` return value cancels retry).

By default, it retries *only* on the specified methods, status codes, and on these network errors:
- `ETIMEDOUT`: One of the [timeout](#timeout) limits were reached.
- `ECONNRESET`: Connection was forcibly closed by a peer.
- `EADDRINUSE`: Could not bind to any free port.
- `ECONNREFUSED`: Connection was refused by the server.
- `EPIPE`: The remote side of the stream being written has been closed.
- `ENOTFOUND`: Couldn't resolve the hostname to an IP address.
- `ENETUNREACH`: No internet connection.
- `EAI_AGAIN`: DNS lookup timed out.

__Note:__ Got does not retry on `POST` by default.
__Note:__ If `maxRetryAfter` is set to `undefined`, it will use `options.timeout`.
__Note:__ If [`Retry-After`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After) header is greater than `maxRetryAfter`, it will cancel the request.
*/
export type RetryOptions = {
    limit: number;
    methods: Method[];
    statusCodes: number[];
    errorCodes: string[];
    calculateDelay: RetryFunction;
    backoffLimit: number;
    noise: number;
    maxRetryAfter?: number;
};
export type CreateConnectionFunction = (options: NativeRequestOptions, oncreate: (error: NodeJS.ErrnoException, socket: Socket) => void) => Socket;
export type CheckServerIdentityFunction = (hostname: string, certificate: DetailedPeerCertificate) => NodeJS.ErrnoException | void;
export type CacheOptions = {
    shared?: boolean;
    cacheHeuristic?: number;
    immutableMinTimeToLive?: number;
    ignoreCargoCult?: boolean;
};
type PfxObject = {
    buffer: string | Buffer;
    passphrase?: string | undefined;
};
type PfxType = string | Buffer | Array<string | Buffer | PfxObject> | undefined;
export type HttpsOptions = {
    alpnProtocols?: string[];
    rejectUnauthorized?: NativeRequestOptions['rejectUnauthorized'];
    checkServerIdentity?: CheckServerIdentityFunction;
    /**
    Override the default Certificate Authorities ([from Mozilla](https://ccadb-public.secure.force.com/mozilla/IncludedCACertificateReport)).

    @example
    ```
    // Single Certificate Authority
    await got('https://example.com', {
        https: {
            certificateAuthority: fs.readFileSync('./my_ca.pem')
        }
    });
    ```
    */
    certificateAuthority?: SecureContextOptions['ca'];
    /**
    Private keys in [PEM](https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail) format.

    [PEM](https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail) allows the option of private keys being encrypted.
    Encrypted keys will be decrypted with `options.https.passphrase`.

    Multiple keys with different passphrases can be provided as an array of `{pem: <string | Buffer>, passphrase: <string>}`
    */
    key?: SecureContextOptions['key'];
    /**
    [Certificate chains](https://en.wikipedia.org/wiki/X.509#Certificate_chains_and_cross-certification) in [PEM](https://en.wikipedia.org/wiki/Privacy-Enhanced_Mail) format.

    One cert chain should be provided per private key (`options.https.key`).

    When providing multiple cert chains, they do not have to be in the same order as their private keys in `options.https.key`.

    If the intermediate certificates are not provided, the peer will not be able to validate the certificate, and the handshake will fail.
    */
    certificate?: SecureContextOptions['cert'];
    /**
    The passphrase to decrypt the `options.https.key` (if different keys have different passphrases refer to `options.https.key` documentation).
    */
    passphrase?: SecureContextOptions['passphrase'];
    pfx?: PfxType;
    ciphers?: SecureContextOptions['ciphers'];
    honorCipherOrder?: SecureContextOpt